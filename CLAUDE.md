<!-- superpower-skills-start -->

# Superpowers Skills

ALWAYS check if a superpowers skill applies before starting any task.

## Core

- ALWAYS use systematic-debugging — Four-phase root cause analysis — read errors, reproduce, trace data flow, fix
- ALWAYS use test-driven-development — RED-GREEN-REFACTOR cycle — write failing test first, minimal code, then clean up
- ALWAYS use verification-before-completion — Run verification commands and confirm output before claiming work is done
- ALWAYS use property-based-testing — Property-based testing guidance across languages and smart contracts for stronger coverage

## Workflow

- Use brainstorming for collaborative design exploration — understand intent, propose approaches, get approval
- Use writing-plans for create detailed implementation plans with bite-sized tasks and dependencies
- Use executing-plans for batch execution of implementation plans with human review checkpoints
- Use dispatching-parallel-agents for launch concurrent subagent workflows for independent tasks
- Use subagent-driven-development for two-stage review process for autonomous task execution with quality gates
- Use doc-coauthoring for structured workflow for co-authoring documentation, proposals, and technical specs

## Git & Code Review

- Use using-git-worktrees for create and manage isolated git worktrees for feature development
- Use requesting-code-review for pre-review checklist — validate tasks, run tests, prepare pr for review
- Use receiving-code-review for systematically handle review feedback and incorporate changes
- Use finishing-a-development-branch for merge/pr decisions, branch cleanup, and post-merge verification
- Use differential-review for security-focused differential review of prs, commits, and diffs

## Languages

- Use typescript-pro — Advanced TypeScript — generics, type guards, utility types, tRPC, monorepo setup

## Security

- Use security-reviewer for security analysis — security audits, sast scans, penetration testing, devsecops, cloud security reviews
- Use semgrep-rule-creator for security analysis — create custom semgrep rules for detecting vulnerabilities and code patterns
- Use variant-analysis for security analysis — find similar vulnerabilities across codebases using codeql/semgrep pattern analysis
- Use sharp-edges for security analysis — identify error-prone apis, dangerous configs, and footgun designs in code
- Use insecure-defaults for security analysis — detect fail-open insecure defaults — hardcoded secrets, weak auth, permissive configs
- Use audit-context-building for security analysis — ultra-granular line-by-line code analysis for deep architectural context before auditing
- Use second-opinion for security analysis — run external llm code reviews (codex/gemini cli) on diffs and commits
- Use constant-time-analysis for security analysis — detect timing side-channel vulnerabilities in cryptographic code
- Use spec-to-code-compliance for security analysis — verify code implements exactly what documentation specifies — spec vs implementation gaps
- Use semgrep-rule-variant-creator for security analysis — port existing semgrep rules to other target languages
<!-- superpower-skills-end -->
